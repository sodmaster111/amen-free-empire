# План backend-системы AMEN FREE EMPIRE — Архитектурная версия 1.0

## 1. Назначение backend
- Обеспечить единый серверный контур, который предоставляет API и сервисные возможности для всех пользовательских и внутренних интерфейсов AMEN FREE EMPIRE.
- Координировать выполнение бизнес-процессов, связанных с управлением миссиями, кооперативными активностями и взаимодействием с AI-агентами.
- Служить точкой расширения для интеграций (Telegram, внешние провайдеры) и будущей эволюции платформы при сохранении целостной архитектуры.

## 2. Архитектура backend
- **Подход**: модульный монолит на Node.js/TypeScript, разделённый на сервисные домены и общие платформенные библиотеки. На первом этапе всё разворачивается в одном приложении.
- **Слои**:
  - *Представление API*: HTTP-контроллеры, обеспечивающие маршрутизацию запросов и возврат стандартизированных ответов.
  - *Сервисный слой*: бизнес-логика доменов, работа с очередями задач, orchestration AI-агентов.
  - *Адаптеры интеграций*: обёртки над внешними сервисами (Telegram, будущие AI-провайдеры, временные in-memory хранилища).
  - *Инфраструктурные утилиты*: логирование, конфигурация, централизованная обработка ошибок, валидация.
- **Потоки данных**:
  - HTTP API принимает запросы от фронтенда и внешних клиентов, передаёт их в сервисы, которые при необходимости ставят задачи в очередь исполнителя.
  - Фоновые задачи обрабатывают долгие операции, синхронизируются с модулем AI-агентов или Telegram-интеграцией.
  - Вся оперативная информация на первом этапе хранится в памяти процесса (структуры JS/TS); предусмотрены точки абстракции для дальнейшего перехода на постоянное хранилище.
- **Среды**:
  - *Local*: разработка, горячая перезагрузка, подробные логи.
  - *Staging*: тестирование интеграций, ограниченные ключи Telegram/AI, эмуляция данных.
  - *Production*: минимальный стек сервисов, развёртывание контейнером, строгие настройки окружения и мониторинга.

## 3. Компоненты

### 3.1 HTTP API (Express или Fastify)
- **Назначение**: основной входной слой для веб-клиента, внутренних инструментов и будущих мобильных приложений.
- **Базовые возможности**:
  - RESTful маршруты для управления миссиями, профилями участников, задачами, очередями.
  - Единую систему аутентификации (на старте — простые токены или сессии в памяти).
  - Валидацию входных данных и единый формат ошибок (JSON-ответы с кодами и деталями).
- **Архитектура**:
  - Структура каталогов по доменам (`/api/missions`, `/api/agents`, `/api/telegram`).
  - Использование middleware для логирования, трекинга запросов, CORS, rate limiting (конфигурируемые настройки).
  - Контроллеры вызывают сервисы, не взаимодействуют напрямую с очередями или внешними API.
- **Расширение**: подготовить поддержку WebSocket/Server-Sent Events для real-time уведомлений после стабилизации REST-интерфейсов.

### 3.2 Task Worker (фоновая система)
- **Назначение**: выполнять длительные операции и отделять тяжёлые вычисления от пользовательских запросов.
- **Рабочий процесс**:
  - HTTP API добавляет задания в in-memory очередь (например, простая структура на базе массивов/Map).
  - Работники подписываются на типы заданий (генерация миссий, рассылки уведомлений, взаимодействие с AI).
  - Обработка задач с повторными попытками, дедлайнами и логированием результатов.
- **Инфраструктура**:
  - Единый модуль диспетчеризации, позволяющий в будущем заменить очередь на Redis/RabbitMQ без изменения доменного кода.
  - Поддержка cron-подобных расписаний для периодических задач (например, обновление статусов миссий).
  - Канал обратной связи с API (через события или обновление общего in-memory состояния), чтобы клиенты могли получить результаты выполнения.

### 3.3 Модуль интеграции с Telegram (скелет будущего бота)
- **Назначение**: готовая точка подключения Telegram-бота, обеспечивающая коммуникацию с пользователями внутри мессенджера.
- **Функциональность первой версии**:
  - Конфигурация webhook или polling, переключаемая через настройки окружения.
  - Обработка базовых команд (`/start`, `/help`), регистрация или связывание Telegram-профиля с профилем пользователя в системе (через in-memory mapping).
  - Пересылка ключевых событий из backend (например, новая миссия) в Telegram через фоновые задачи.
- **Архитектурные требования**:
  - Выделенный адаптер поверх Telegram Bot API, скрывающий детали HTTP-вызовов.
  - Механизм очереди для входящих/исходящих сообщений (взаимодействие с Task Worker).
  - Логирование и трассировка всех взаимодействий для аудита и отладки.
- **План развития**: поддержка интерактивных сценариев, inline-режима, работы с платежами после появления постоянного хранилища.

### 3.4 Модуль для AI-агентов
- **Назначение**: централизованная оркестрация всех AI-агентов (внутренних и внешних), их диалогов и задач.
- **Структура**:
  - Интерфейсы для агентов (инициализация, получение контекста, выполнение задачи, возврат результата).
  - Управление состоянием агента в памяти (контекст диалога, последняя активность, связанный пользователь).
  - Планировщик взаимодействий, который решает, когда вызывать агента (триггеры от API, расписания, Telegram-события).
- **Интеграции**:
  - Абстрактный клиент для LLM-провайдеров (OpenAI, локальные модели). На первом этапе — моковые реализации, хранящие ответы в памяти.
  - Обратные вызовы в Task Worker для тяжёлых вычислений (например, генерация контента).
- **Безопасность и аудит**:
  - Централизованный лог действий агентов (кто инициировал, какие входные данные, какой ответ), хранится в in-memory структуре с возможностью экспорта.
  - Ограничения по ресурсам (тайм-ауты, лимиты на количество запросов).

## 4. Минимальный стек
- **Язык и рантайм**: Node.js LTS + TypeScript (строгая типизация, `tsconfig` с модульным путём).
- **HTTP-фреймворк**: Express (по умолчанию) или Fastify (как альтернатива с повышенной производительностью); выбрать один и придерживаться единообразия.
- **Управление состоянием**: in-memory структуры JavaScript/TypeScript (Map, Set, кастомные классы) с чёткими интерфейсами для дальнейшей замены на БД.
- **Асинхронность**: использование `async/await`, централизованный обработчик ошибок, единый механизм отмены (AbortController) для долгих операций.
- **Инструменты разработки**: ESLint + Prettier, Jest для модульных тестов, nodemon/ts-node-dev для локальной перезагрузки, simple logger (pino или winston).
- **Развёртывание**: Dockerfile c multi-stage сборкой (build + runtime), переменные окружения через `.env` или систему секретов, базовый мониторинг (health-check endpoints, структурированные логи).

## 5. Дополнительные архитектурные решения
- **Модульность кода**: разделение по доменам и техническим слоям, `index.ts` в каждом модуле экспортирует публичные контракты.
- **Контракты данных**: использование DTO и схем валидации (zod или class-validator), единый namespace `@amen/shared` для повторно используемых типов.
- **Тестирование**: стратегический набор модульных тестов для API и воркеров, сценарные тесты для Telegram и AI-модулей с использованием моков.
- **Наблюдаемость**: базовый `requestId` middleware, централизованный журнал событий, подготовка к интеграции с внешним APM.
- **Эволюция**: закладка абстракций для перехода на постоянное хранилище, горизонтальное масштабирование воркеров и разделение приложения на микросервисы при росте нагрузки.
